

# This file was *autogenerated* from the file funcs.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_9999 = Integer(9999); _sage_const_9 = Integer(9); _sage_const_5 = Integer(5); _sage_const_99 = Integer(99); _sage_const_4 = Integer(4); _sage_const_3 = Integer(3)
class Lattice():
    def __init__(self,basis):
        ## We first get a BKZ-reduced basis in sage this does the same as .LLL i believe
        B = Matrix(ZZ,basis).BKZ()
        self.B = B.T # paper uses column sage uses rows haiz
        self.basis = list(B)
        self.dim = len(basis)
        m = len(basis[_sage_const_0 ]) # ambient space dimension
        self.det = det(B*B.T)
        self.rd = _sage_const_1  # i have no idea how to compute \gamma_n and i dont think it really matters?
        self.A = sqrt(m)*abs(self.det)**(_sage_const_1 /m)# estimate for lambda_1

        ## L_t, pi_t, zeta_t. Note that for my sanity I start t from 0
        self.basis_t = []
        self.det_t = []
        pi_gens_t = None
        self.pi_t = []
        self.zeta_t = []
        for t in range(self.dim):
            self.basis_t.append(list(B[:t]))
            self.det_t.append(det(B[:t]*B[:t].T))
            pi_gens_t = B[:t].right_kernel().matrix().gram_schmidt()[_sage_const_0 ]
            pi_t = lambda v: sum((w*v)/(w*w)*w for w in pi_gens_t)
            zeta_t = lambda v: v-pi_t(v)
            M = []
            for j in range(m):
                M.append(pi_t(vector(_sage_const_1  if i==j else _sage_const_0  for i in range(m))))
            self.pi_t.append(Matrix(QQ,m,m,M))
            M = []
            for j in range(m):
                M.append(zeta_t(vector(_sage_const_1  if i==j else _sage_const_0  for i in range(m))))
            self.zeta_t.append(Matrix(QQ,m,m,M))
    def rho_t(self,t):
        return lambda b:sqrt(self.A**_sage_const_2 -(self.pi_t[t]*b).norm()**_sage_const_2 )
    def beta_t(self,t):
        return lambda b:self.rho_t(t)(b)**(t-_sage_const_1 )*pi**((t-_sage_const_1 )/_sage_const_2 )/(self.det_t[t]*gamma((t+_sage_const_1 )/_sage_const_2 ))

v = [vector(randint(-_sage_const_9999 ,_sage_const_9999 ) for _ in range(_sage_const_9 )) for _ in range(_sage_const_5 )]
L = Lattice(v)
pi2 = L.pi_t[_sage_const_2 ]
zeta2 = L.zeta_t[_sage_const_2 ]
w = vector(randint(-_sage_const_99 ,_sage_const_99 ) for _ in range(_sage_const_9 ))
print((pi2*w)*(zeta2*w)) # sanity check
print(L.det_t[_sage_const_4 ]*L.beta_t(_sage_const_4 )(w)/L.rho_t(_sage_const_4 )(w)**_sage_const_3 ) # make sure volume of 3-ball is actually 4/3 pi r^3
for i in range(_sage_const_5 ):
    print(n(L.beta_t(i)(w))) # these should all be between 0 and 1 as they are probabilities


